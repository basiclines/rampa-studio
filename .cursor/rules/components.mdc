---
description: How to create dumb ui components and more complex application related logic components
globs: 
alwaysApply: false
---
# Component Architecture Guide

This application follows a two-tier component architecture that separates generic UI patterns from application-specific behavior.

## @/components/ui/ - Generic UI Components

**Purpose**: Dumb, reusable UI components for generic patterns
**State**: May contain local state for simple interactions (open/close, hover, focus)
**Dependencies**: Zero application dependencies

### Characteristics:
- ✅ Stateless or simple local state only
- ✅ Reusable across different applications
- ✅ Props-driven behavior
- ✅ No business logic
- ✅ No usecase dependencies

## @/components/ - Application Components

**Purpose**: Application-specific components that implement business features
**State**: Use usecases for all application state
**Dependencies**: Import and use usecases, never modify state directly

### Characteristics:
- ✅ Use usecase hooks for all business logic
- ✅ Never directly modify application state
- ✅ Explicit about behavior through usecase usage
- ✅ Avoid prop drilling of state setters
- ✅ Composed of @/components/ui/ components

## Key Principles

### 1. Clear Separation
- **UI components**: Generic, reusable, no application knowledge
- **Application components**: Feature-specific, usecase-driven

### 2. State Management
- **UI components**: Local state for UI interactions only
- **Application components**: All business state through usecases

### 3. Composition
- **Application components** are built using **UI components**
- **UI components** never import from application layer

### 4. Explicit Behavior
- No prop drilling of complex state or setters
- Each component clearly shows what business operations it performs
- Usecases make component behavior explicit and testable

This architecture ensures components are testable, maintainable, and follow clear responsibility boundaries. 